normalize_genename <- function(gene) {
  # Make gene names legal colnames which can be safely reversed by removing the "gn_" prefix
  genelist <- paste0("gn_", gene)
  genelist <- make.names(genelist, unique = FALSE)
  return(genelist)
}


denormalize_genename <- function(gene) {
  name <- substr(start = 4, stop = nchar(gene), gene)
  return(name)
}


#' Make an Reference for Gene Name Conversion
#'
#' \code{make_database()} loads gene name / ID conversion tables from online
#' databases (e.g., FlyBase) and a user-provided GTF file that is used to
#' annotate the features of the NGS dataset of interest (e.g., the GTF file
#' STAR or \code{cellranger count} uses).
#'
#' @param species a character string describing the species of the genes.
#' (Options: "\code{dmel}")
#' @param gtf.path a character string containing the path to the GTF file
#' containing the input gene names (e.g., the GTF files used by
#' \code{cellranger count})
#' @param version
#'
#' @return a list containing multiple coversion tables and meta data
#' @export
#'
#' @examples
#' dmeldb <- make_database(species = "dmel",
#'                            gtf.path = "extdata/dummy.gtf")
make_database <- function(species = "dmel", gtf.path, version = NULL) {
  db <- prepare_database(species = species,
                         gtf.path = gtf.path,
                         version = version)

  # Generate conversion vectors from the synonym table
  dict <- generate_flybase_sym(db[["syno"]])
  db <- db[names(db) != "syno"]
  db[["symbol_dict"]] <- db[["symbol"]]
  db[["alias_dict"]] <- db[["alias"]]

  return(db)
}


prepare_database <- function(species = "dmel", gtf.path, version = NULL) {
  if (!species %in% c("dmel", "test")) {
    stop("prepare_database does not support ", species, " now.")
  }
  # Load GTF file (contains gene id and names)
  id_mapping <- rtracklayer::import(gtf.path)
  id_mapping <- as.data.frame(id_mapping)
  id_mapping <- id_mapping[id_mapping$type == "gene", ]

  # Load data from species-specific gene databases
  if (species == "dmel") {
    result <- fetch_flybase(version = version)
  }
  # Keep gene id and gene name from the GTF file
  gtf <- id_mapping[ , c("gene_id", "gene_name")]
  result[["gtf"]] <- gtf
  result[["species"]] <- species

  return(result)
}


#' Generate Conversion Tables for Symbols and Aliases to FlyBase ID
#'
#' @param db a list generated by \code{\link{prepare_database}()}
#'
#' @return a list of 2 (a named vector that translate symbols to FB ids and
#' another that translates aliases to FB ids)
generate_flybase_sym <- function (db) {
  # Generate a a named vector for conversion based on Flybase Synonym
  # with which you can use alias/name to query FBid
  # Usage: named_vector <- generate_flybase_sym([the tsv file])
  # named_vector[*alias/name*] gives its corresponding flybase id
  fbsym <- db[["syno"]]

  # Keep only Drosophila genes
  colnames(fbsym)[1] <- "primary_fbid"
  fbsym <- fbsym[fbsym$organism_abbreviation == "Dmel", ]
  fbsym <- fbsym[grepl("^FBgn", fbsym$primary_fbid), ]

  # Generate a named vector with *aliases as names* and
  # *fbid as values*
  alias_dict_list <- list()
  for (row in seq(nrow(fbsym))) {
    alias <- strsplit(fbsym[row, "symbol_synonym(s)"], ",")[[1]]
    if (length(alias) > 0) {
      fbid <- fbsym[row, "primary_fbid"]
      dict <- rep(fbid, length(alias))
      names(dict) <- normalize_genename(alias)
      alias_dict_list[[fbid]] <- dict
    }
  }

  alias_dict <- unlist(alias_dict_list)

  # Since unlist appends names of the list items to names of vector items
  # For example, if ChAT is #10000 in the file, before unlist() the
  # name:value would be ChAT:FBid
  # After unlist it would be 10000.ChAT:FBid
  # I'll remove the list item names (the "10000." part) for they disrupt
  # mapping
  names(alias_dict) <- gsub("^[0-9]*\\.", "", names(alias_dict))

  # Generate a named vector with *symbols as names* and
  # *fbid as values*
  symbol_dict <- fbsym$primary_fbid
  names(symbol_dict) <- normalize_genename(fbsym$current_symbol)
  dict_obj <- list("symbol" = symbol_dict,
                   "alias" = alias_dict)
  return(dict_obj)
}


#' Generate a Mapping Vector to Translate Gene IDs
#'
#' \code{generate_gene_mapping()} takes gene names from a character vector, an
#' expression matrix / data frame, or a Seurat object, and generate a vector
#' that can be used to translate gene IDs to the gene names provided to
#' \code{generate_gene_mapping()}. The purpose of this translation is to make
#' sure different datasets are consistent in the gene names used during
#' analysis, and to thereby ensure comparsion between datasets or querying are
#' accurate.
#' @param x a character vector, a data frame / matrix containing an expression
#' matrix, or a Seurat object
#' @param db a list generated by \code{\link{prepare_database}()}
#' @param ... other arguments that are passed to \code{\link{get_gene_names}()}
#' (see below)
#' @inheritParams get_gene_names
#'
#' @return a named character vector, in which the values are gene names and
#' the names are gene ids
#'
#' @examples
generate_gene_mapping <- function(x, db, ...) {
  # Check if db is legit
  if (!"gtf" %in% names(db)) {
    stop(strwrap("The database list seems to be wrong. Please make sure that
                 you generated it by prepare_database() before using gene
                 name conversion functions."))
  }
  id_mapping <- db[["gtf"]]

  # If x is not already a character vector, get gene names from x first
  if (!is.character(x)) {
    x <- get_gene_names(x, ...)
  }

  # Check if there are genes not found in the reference
  x_found <- x[x %in% id_mapping$gene_name]
  if (length(x) != length(x_found)) {
    warning(strwrap("Some gene names are not found in the GTF file.
            Please check if the version is correct."))
    message("The genes not seen in the GTF file include: ",
            paste(setdiff(x, x_found), collapse = ", "),
            ".")
  }

  # Only keep the part of GTF that contains the input gene names
  id_mapping <- id_mapping[id_mapping$gene_name %in% x, ]

  # Update gene ID
  if (db[["species"]] == "dmel") {
    id_mapping$gene_id <- update_fbid(id_mapping$gene_id)
  }

  result <- id_mapping$gene_name
  names(result) <- id_mapping$gene_id
  return(result)
}


update_fbid <- function (id) {
  # Convert out-dated FBid to current version
  ## Load lookup table
  if (!file.exists(fbid_obj)) {
    generate_fbid_version_table(fbid_table)
  }
  version_dict <- readRDS(fbid_obj)
  ## Find FBid that need conversion
  index_update <- id %in% names(version_dict)
  ## Convert with lookup table while keeping the order
  result <- sapply(seq(length(id)), function (x) {
    if (index_update[x]) {
      return(version_dict[id[x]])
    }
    return(id[x])
  })
  result <- unname(result)
  return(result)
}

generate_fbid_version_table <- function(path) {
  ## Read the FBgn annotation table from FlyBase
  id_table <- data.table::fread(input = path, header = TRUE,
                                sep = "\t", stringsAsFactors = FALSE,
                                data.table = TRUE)
  print(contable_ver)
  query <- id_table$`secondary_FBgn#(s)`
  names(query) <- id_table$`primary_FBgn#`
  lookup <- lapply(names(query), function(x) {
    old_id <- strsplit(query[[x]], split = ",")[[1]]
    if (length(old_id) > 0) {
      result <- rep(x, length(old_id))
      names(result) <- old_id
      return(result)
    }
  })
  lookup <- lookup[sapply(lookup, function(x) !is.null(x))]
  lookup <- unlist(lookup)
  saveRDS(object = lookup, file = fbid_obj)
  print("The version table is sucessfully generated and saved.")
  return(0)
}



categorize_gene <- function(name, flybase_sym) {
  # Separate gene names to 2 categories
  # 1. Matching current symbol
  # 2. Matching aliases

  ## Remove mitochondrial genes
  name <- name[!grepl("^mt:", name)]
  name <- normalize_genename(name)
  ## Here I suppose that genes with names matching official symbols do not need conversion
  in_symbol <- name[name %in% names(flybase_sym[["symbol"]])]
  names(in_symbol) <- flybase_sym[["symbol"]][in_symbol]
  not_in_symbol <- name[!name %in% names(flybase_sym[["symbol"]])]
  alias <- not_in_symbol[not_in_symbol %in% names(flybase_sym[["alias"]])]
  names(alias) <- flybase_sym[["alias"]][alias]

  ## Create warnings if there's multiple mapping for aliases
  for (item in not_in_symbol) {
    matching_num <- sum(names(flybase_sym[["alias"]]) == item)
    if (matching_num > 1) {
      warning(paste0("'", denormalize_genename(item), "' is matched with multiple aliases. ",
                     "Please check the FB id generated here to determine if the mapping is correct."))
    }
  }

  ## Remind the user about non-convertible gene names
  unmapped <- setdiff(not_in_symbol, alias)
  if (length(unmapped) > 0) {
    unmapped <- paste(unmapped, collapse = ", ")
    warning(paste0("Please note the following genes are not found in the database and won't be processed: ",
                   denormalize_genename(unmapped), "."))
  }
  genelist <- list("symbol" = in_symbol, "alias" = alias)
  return(genelist)
}

convert_fbid <- function(name, flybase_sym) {
  # Convert a list of fly gene to flybase id
  ## Get a list of dataframes with a conversion table with Flybase IDs and symbol/alias
  genelist <- categorize_gene(name, flybase_sym = flybase_sym)
  fbid <- unique(c(names(genelist[["symbol"]]), names(genelist[["alias"]])))
  return(fbid)
}

convert_10Xgenename <- function(name, flybase_sym, dict10X) {
  # Convert a list of fly gene names to make it compatible
  # with the 10X gene names in the Seurat object

  ## Generate a named list from the Seurat object
  ## work as a dictionary for conversion

  ## Convert input names to Fbid
  input_fbid <- convert_fbid(name, flybase_sym)
  ## Throw away genes that are not present in 10X
  input_fbid <- input_fbid[input_fbid %in% names(dict_10X)]
  name_10Xformat <- dict_10X[input_fbid]
  name_10Xformat <- normalize_genename(name_10Xformat)
  return(name_10Xformat)
}